"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[744],{4529:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>w,contentTitle:()=>f,default:()=>x,frontMatter:()=>g,metadata:()=>b,toc:()=>y});var s=i(7462),r=(i(7294),i(3905)),h=i(5853),n=i(708),o=i(7888),a=i(8788),l=i(4394),c=i(546),d=i(6896),p=i(7421);class u extends c.W{constructor(){super(...arguments),this._trackObject=new o.s,this._camera=new o.s}withTrackObject(t){return this._trackObject=t,this}getCamera(t){return this._camera=t,this}make(){return this.gameObjectBuilder.withComponent(d.V).withComponent(p.K,(t=>{t.smoothTrack=!0,this._trackObject.ref&&t.setTrackTarget(this._trackObject.ref)})).getComponent(d.V,this._camera)}}class m extends n.A{run(){const t=this.instantiater,e=new o.s,i=new o.s;return this.sceneBuilder.withChild(t.buildPrefab("camera",u).withTrackObject(e).getCamera(i).make()).withChild(t.buildGameObject("player").withComponent(a._).withComponent(l.j).getGameObject(e))}}const g={},f="Prefab",b={unversionedId:"getting-started/prefab",id:"getting-started/prefab",title:"Prefab",description:"If you keep writing scenes on the bootstrapper, the bootstrapper will become too big.",source:"@site/docs/1-getting-started/7-prefab.mdx",sourceDirName:"1-getting-started",slug:"/getting-started/prefab",permalink:"/the-world-engine.ts/build/docs/getting-started/prefab",draft:!1,editUrl:"https://github.com/The-World-Space/the-world-engine.ts/tree/main/docs/docusaurus/docs/1-getting-started/7-prefab.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Get Component",permalink:"/the-world-engine.ts/build/docs/getting-started/get-component"},next:{title:"Add/Remove Object Dynamically",permalink:"/the-world-engine.ts/build/docs/getting-started/add-object-dynamically"}},w={},y=[{value:"Make a prefab",id:"make-a-prefab",level:2},{value:"Add a prefab to the builder",id:"add-a-prefab-to-the-builder",level:2}],C={toc:y};function x(t){let{components:e,...i}=t;return(0,r.kt)("wrapper",(0,s.Z)({},C,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"prefab"},"Prefab"),(0,r.kt)("p",null,"If you keep writing scenes on the bootstrapper, the bootstrapper will become too big."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"You can use prefab to separate scene builds"),". It's like separating components in React development."),(0,r.kt)("h2",{id:"make-a-prefab"},"Make a prefab"),(0,r.kt)("p",null,"We going to make a camera prefab that tracks a specific object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="./src/asset/prefab/CameraPrefab.ts"',title:'"./src/asset/prefab/CameraPrefab.ts"'},'import { \n    Camera,\n    GameObject,\n    GameObjectBuilder,\n    Prefab,\n    PrefabRef,\n    TrackCameraController\n} from "the-world-engine";\n\nexport class CameraPrefab extends Prefab {\n    private _trackObject = new PrefabRef<GameObject>();\n    private _camera = new PrefabRef<Camera>();\n\n    //If you add a value inside the prefab from the outside, you can create the with method\n    public withTrackObject(trackObject: PrefabRef<GameObject>): this {\n        this._trackObject = trackObject;\n        return this;\n    }\n\n    //When receiving the value inside the prefab from the outside, it is possible by creating the get method\n    public getCamera(componentRef: PrefabRef<Camera>): this {\n        this._camera = componentRef;\n        return this;\n    }\n\n    public override make(): GameObjectBuilder {\n        return this.gameObjectBuilder\n            .withComponent(Camera)\n            .withComponent(TrackCameraController, c => {\n                c.smoothTrack = true;\n                if (this._trackObject.ref) c.setTrackTarget(this._trackObject.ref);\n            })\n            .getComponent(Camera, this._camera)\n        ;\n    }\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},'It is recommended that the method of exporting something from a prefab starts with the name "with"\nAnd it is recommended that the method of getting something from the prefab starts with the name "get".')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},'You can see that the implementation of the "get" method and the "with" method is the same, because it works as a call by reference.'),(0,r.kt)("p",{parentName:"admonition"},"Eventually, the behavior is determined by whether the reference is read or written inside the prefab."),(0,r.kt)("p",{parentName:"admonition"},"For this code, ",(0,r.kt)("inlineCode",{parentName:"p"},"this._camera"),' will be exposed as "get" method because the value was writed at ',(0,r.kt)("inlineCode",{parentName:"p"},".getComponent(Camera, this._camera)")),(0,r.kt)("p",{parentName:"admonition"},"And ",(0,r.kt)("inlineCode",{parentName:"p"},"this._trackObject"),' will be exposed as "with" method because the value was readed at ',(0,r.kt)("inlineCode",{parentName:"p"},"if (this._trackObject.ref) c.setTrackTarget(this._trackObject.ref);"))),(0,r.kt)("h2",{id:"add-a-prefab-to-the-builder"},"Add a prefab to the builder"),(0,r.kt)("p",null,"Now we can create camera from CameraPrefab."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="./src/asset/Bootstrapper.ts"',title:'"./src/asset/Bootstrapper.ts"'},'import { /*...*/ } from "the-world-engine";\nimport { CameraPrefab } from "./prefab/CameraPrefab";\n\nexport class Bootstrapper extends BaseBootstrapper {\n    public run(): SceneBuilder {\n        const instantiater = this.instantiater;\n\n        const trackObject = new PrefabRef<GameObject>();\n        const camera = new PrefabRef<Camera>();\n\n        return this.sceneBuilder\n            .withChild(instantiater.buildPrefab("camera", CameraPrefab) // build prefab!\n                .withTrackObject(trackObject)\n                .getCamera(camera)\n                .make())\n\n            .withChild(instantiater.buildGameObject("player")\n                .withComponent(CssSpriteRenderer)\n                .withComponent(PlayerGridMovementController)\n                .getGameObject(trackObject))\n        ;\n    }\n}\n')),(0,r.kt)(h.Z,{bootstrapper:m,allowScroll:!0,mdxType:"DocumentGame"}))}x.isMDXComponent=!0},546:(t,e,i)=>{i.d(e,{W:()=>r});var s=i(8018);class r{constructor(t,e,i,r,h){this._instantiater=t.instantiater,this._gameObjectBuilder=new s.f(t,e,i,r,h)}get instantiater(){return this._instantiater}get gameObjectBuilder(){return this._gameObjectBuilder}}},7888:(t,e,i)=>{i.d(e,{s:()=>s});class s{constructor(t=null){this.ref=t}}},4394:(t,e,i)=>{i.d(e,{j:()=>a});var s=i(6120),r=i(621);class h{constructor(t,e){this.nh=t,this.ah=e,this.uh=0,this.gh=0,this.Ch=0,this.dh=null,this.ph=!0}calculateFCost(){this.Ch=this.uh+this.gh}equals(t){return this.nh===t.nh&&this.ah===t.ah}get x(){return this.nh}get y(){return this.ah}get gCost(){return this.uh}set gCost(t){this.uh=t}get hCost(){return this.gh}set hCost(t){this.gh=t}get fCost(){return this.Ch}set fCost(t){this.Ch=t}get isWalkable(){return this.ph}set isWalkable(t){this.ph=t}get previousNode(){return this.dh}set previousNode(t){this.dh=t}}class n{constructor(t,e=.5,i=.5,s=1e3){var r;this.mr=null!==(r=null==t?void 0:t.slice())&&void 0!==r?r:[],this.eo=e,this.ho=i,this.lo=s}addCollideMap(t){this.mr.push(t)}removeCollideMap(t){const e=this.mr.indexOf(t);e>=0&&this.mr.splice(e,1)}removeAllCollideMaps(){this.mr.length=0}findPath(t,e){const i=new h(t.x,t.y),s=new h(e.x,e.y);if(this.ao(i.x,i.y))return null;if(this.ao(s.x,s.y))return null;const r=[],n=[];i.gCost=0,i.hCost=this.co(i,s),i.calculateFCost(),r.push(i);let o=0;for(;r.length>0&&o<this.lo;){o++;const t=this.uo(r);if(t.equals(s))return this.do(t);r.splice(r.indexOf(t),1),n.push(t);const e=this.fo(t);for(let i=0;i<e.length;++i){const h=e[i];if(void 0!==n.find((t=>t.equals(h))))continue;if(h.gCost=Number.MAX_VALUE,h.calculateFCost(),h.previousNode=null,this.ao(h.x,h.y)){n.push(h);continue}const o=t.gCost+this.co(t,h);o<h.gCost&&(h.previousNode=t,h.gCost=o,h.hCost=this.co(h,s),h.calculateFCost(),void 0===r.find((t=>t.equals(h)))&&r.push(h))}}return null}fo(t){const e=[];return e.push(new h(t.x,t.y-1)),e.push(new h(t.x+1,t.y)),e.push(new h(t.x,t.y+1)),e.push(new h(t.x-1,t.y)),e}do(t){const e=[];let i=t;for(;i.previousNode;)e.push(new s.F(i.x,i.y)),i=i.previousNode;return e.push(new s.F(i.x,i.y)),e.reverse()}co(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}uo(t){let e=t[0];for(let i=1;i<t.length;++i)t[i].fCost<e.fCost&&(e=t[i]);return e}ao(t,e){const i=this.mr;for(let s=0;s<i.length;++s){const r=i[s];if(r.checkCollision(t*r.gridCellWidth+r.gridCenterX,e*r.gridCellHeight+r.gridCenterY,this.eo,this.ho))return!0}return!1}}var o=i(274);class a extends o.T{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this.Ph=8,this.Th=1,this.Ih=1,this.mr=[],this.Lh=.5,this.Rh=new s.F,this.Uh=new s.F,this.Hh=new s.F,this.Kh=new s.F,this.Oh=new r.n,this.Wh=new r.n,this.gr=null,this.wr=null,this.Jh=!1,this.Nh=null,this.Qh=0,this.Xh=null,this.Yh=new s.F,this.Zh=!0,this.$h=new s.F,this.Dr=new s.F,this.Mr=-1,this.Ar=new s.F,this.Vr=.3,this.Cr=t=>{if(0!==t.button)return;this.Jh=!1;const e=this.engine.time.unscaledTime;e-this.Mr<this.Vr?this.Ar.equals(t.gridPosition)&&(this.Tr(t),this.Mr=-1):(this.Mr=e,this.Ar.copy(t.gridPosition))}}start(){this.wr=new n(this.mr,this.Ih*this.Lh,this.Th*this.Lh);const t=this.transform,e=t.position;e.x=this.Rh.x+this.Kh.x*this.Ih,e.y=this.Rh.y+this.Kh.y*this.Th,this.Uh.set(t.localPosition.x,t.localPosition.y);const i=t.parent;i&&this.Yh.set(i.position.x,i.position.y)}update(){var t;null===(t=this.Xh)||void 0===t||t.call(this),this.Zh&&this.Ir(),this.kr(),this.Er()}Ir(){if(this.isMoving)return void this.Gr();const t=this.engine.input.map,e=this.Uh;if(t.get("w")||t.get("ArrowUp")){if(this.direction=o.N.Up,this.ao(e.x,e.y+this.Th))return;this.Hh.set(e.x,e.y+this.Th),this.Lr(),this.isMoving=!0}else if(t.get("s")||t.get("ArrowDown")){if(this.direction=o.N.Down,this.ao(e.x,e.y-this.Th))return;this.Hh.set(e.x,e.y-this.Th),this.Lr(),this.isMoving=!0}else if(t.get("a")||t.get("ArrowLeft")){if(this.direction=o.N.Left,this.ao(e.x-this.Ih,e.y))return;this.Hh.set(e.x-this.Ih,e.y),this.Lr(),this.isMoving=!0}else if(t.get("d")||t.get("ArrowRight")){if(this.direction=o.N.Right,this.ao(e.x+this.Ih,e.y))return;this.Hh.set(e.x+this.Ih,e.y),this.Lr(),this.isMoving=!0}}Rr(t){const e=this.engine.input.map;return e.get("w")||e.get("ArrowUp")?(this.direction=o.N.Up,!this.ao(t.x,t.y+this.Th)&&(this.Hh.set(t.x,t.y+this.Th),this.Lr(),!0)):e.get("s")||e.get("ArrowDown")?(this.direction=o.N.Down,!this.ao(t.x,t.y-this.Th)&&(this.Hh.set(t.x,t.y-this.Th),this.Lr(),!0)):e.get("a")||e.get("ArrowLeft")?(this.direction=o.N.Left,!this.ao(t.x-this.Ih,t.y)&&(this.Hh.set(t.x-this.Ih,t.y),this.Lr(),!0)):!(!e.get("d")&&!e.get("ArrowRight"))&&(this.direction=o.N.Right,!this.ao(t.x+this.Ih,t.y)&&(this.Hh.set(t.x+this.Ih,t.y),this.Lr(),!0))}Lr(){this.Oh.invoke(Math.floor((this.Hh.x-this.Rh.x)/this.Ih),Math.floor((this.Hh.y-this.Rh.y)/this.Th))}Ur(){this.Wh.invoke(Math.floor((this.Uh.x-this.Rh.x)/this.Ih),Math.floor((this.Uh.y-this.Rh.y)/this.Th))}Gr(){const t=this.engine.input.map;(t.get("w")||t.get("ArrowUp")||t.get("s")||t.get("ArrowDown")||t.get("a")||t.get("ArrowLeft")||t.get("d")||t.get("ArrowRight"))&&(this.Jh=!1)}kr(){if(!this.Jh)return;const t=this.transform,e=this.$h.set(t.localPosition.x,t.localPosition.y),i=this.Nh[this.Qh];if(i.distanceTo(e)<this.Ph*this.engine.time.deltaTime){if(this.Qh++,this.Qh>=this.Nh.length)return void(this.Jh=!1);this.Ur()}if(this.ao(i.x,i.y))return void(this.Jh=!1);if(this.Hh.equals(this.Nh[this.Qh]))return;this.Hh.copy(this.Nh[this.Qh]),this.Lr();const s=this.Nh[this.Qh-1].x,r=this.Nh[this.Qh-1].y,h=this.Nh[this.Qh].x,n=this.Nh[this.Qh].y;r<n?this.direction=o.N.Up:r>n?this.direction=o.N.Down:s<h?this.direction=o.N.Right:s>h&&(this.direction=o.N.Left),this.isMoving=!0}Er(){if(!this.isMoving)return;const t=this.transform,e=this.$h.set(t.localPosition.x,t.localPosition.y);let i=e.distanceTo(this.Hh);const s=this.Ph*this.engine.time.deltaTime;i<s&&this.Rr(this.Hh)&&(i=e.distanceTo(this.Hh),this.Ur());const r=this.Dr.copy(this.Hh).sub(e).normalize();i<s?(this.isMoving=!1,this.Uh.copy(this.Hh),t.localPosition.x=this.Uh.x,t.localPosition.y=this.Uh.y,this.Ur()):(r.multiplyScalar(s),this.gameObject.transform.localPosition.x+=r.x,this.gameObject.transform.localPosition.y+=r.y)}ao(t,e){t+=this.Yh.x,e+=this.Yh.y;const i=this.mr;for(let s=0;s<i.length;++s)if(i[s].checkCollision(t,e,this.Lh,this.Lh))return!0;return!1}Tr(t){if(this.Jh)return this.Jh=!1,void(this.Xh=()=>{this.tryStartPathfind(t.gridPosition)});this.Xh=()=>{this.tryStartPathfind(t.gridPosition)}}tryStartPathfind(t){if(this.Jh)return!1;this.Xh=null;const e=this.Nh=this.wr.findPath(this.positionInGrid,t);if(!e||e.length<=1)return!1;for(let i=0;i<e.length;++i){const t=e[i];t.x=t.x*this.Ih+this.Rh.x,t.y=t.y*this.Th+this.Rh.y}return this.Qh=1,this.isMoving=!0,this.Jh=!0,!0}cancelPathfind(){this.Jh=!1}get onMoveToTarget(){return this.Oh}get onMovedToTarget(){return this.Wh}teleport(t){this.isMoving=!1,this.Jh=!1,this.Uh.copy(t).multiplyScalar(this.Ih).add(this.Rh),this.Hh.copy(this.Uh),this.transform.localPosition.x=this.Uh.x,this.transform.localPosition.y=this.Uh.y,this.Lr(),this.Ur()}get speed(){return this.Ph}set speed(t){this.Ph=t}get gridCenter(){return this.Rh}set gridCenter(t){this.Rh.copy(t)}get gridCellHeight(){return this.Th}set gridCellHeight(t){this.Th=t}get gridCellWidth(){return this.Ih}set gridCellWidth(t){this.Ih=t}set initPosition(t){this.Kh.copy(t)}set gridPointer(t){this.gr&&this.gr.onPointerDown.removeListener(this.Cr),this.gr=t,this.gr&&this.gr.onPointerDown.addListener(this.Cr)}get gridPointer(){return this.gr}addCollideMap(t){var e;this.mr.push(t),null===(e=this.wr)||void 0===e||e.addCollideMap(t)}removeCollideMap(t){var e;const i=this.mr.indexOf(t);i>=0&&(this.mr.splice(i,1),null===(e=this.wr)||void 0===e||e.removeCollideMap(t))}removeAllCollideMaps(){var t;this.mr.length=0,null===(t=this.wr)||void 0===t||t.removeAllCollideMaps()}setGridInfoFromCollideMap(t){this.Ih=t.gridCellWidth,this.Th=t.gridCellHeight,this.Rh.set(t.gridCenterX,t.gridCenterY)}get positionInGrid(){return new s.F(Math.floor((this.transform.localPosition.x-this.Rh.x)/this.Ih),Math.floor((this.transform.localPosition.y-this.Rh.y)/this.Th))}get receiveKeyboardInput(){return this.Zh}set receiveKeyboardInput(t){this.Zh=t}}},7421:(t,e,i)=>{i.d(e,{K:()=>a});var s=i(6120),r=i(4532),h=i(9542),n=i(3674),o=i(6896);class a extends n.w{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this.requiredComponents=[o.V],this.Or=null,this.jr=new s.F,this.qr=20,this.zr=1,this.Br=!1,this.Fr=!1,this.Hr=6,this.Jr=new r.P}start(){if(this.Or){const t=this.Jr.copy(this.Or.transform.position);t.z+=this.qr,this.transform.position.copy(t)}}update(){const t=this.Jr.copy(this.Or.transform.position);t.z+=this.qr,t.x+=this.jr.x,t.y+=this.jr.y;const e=this.transform;if(this.Fr){const i=this.engine.time.deltaTime,s=this.Hr,r=h.u1(e.position.x,t.x,s,i),n=h.u1(e.position.y,t.y,s,i),o=h.u1(e.position.z,t.z,s,i);e.position.set(r,n,o)}else e.position.copy(t);this.Br&&(e.localPosition.x=Math.round(e.localPosition.x/this.zr)*this.zr,e.localPosition.y=Math.round(e.localPosition.y/this.zr)*this.zr)}setTrackTarget(t){this.Or=t}get targetOffset(){return this.jr}set targetOffset(t){this.jr.copy(t)}get cameraDistanceOffset(){return this.qr}set cameraDistanceOffset(t){this.qr=t}get pixelPerfectUnit(){return this.zr}set pixelPerfectUnit(t){this.zr=t}get pixelPerfect(){return this.Br}set pixelPerfect(t){this.Br=t}get smoothTrack(){return this.Fr}set smoothTrack(t){this.Fr=t}get smoothLambda(){return this.Hr}set smoothLambda(t){this.Hr=t}}},274:(t,e,i)=>{i.d(e,{N:()=>s,T:()=>n});var s,r,h=i(3674);(r=s||(s={}))[r.Up=0]="Up",r[r.Down=1]="Down",r[r.Left=2]="Left",r[r.Right=3]="Right";class n extends h.w{constructor(){super(...arguments),this.xo=s.Down,this.Lo=!1}get direction(){return this.xo}set direction(t){this.xo=t}get isMoving(){return this.Lo}set isMoving(t){this.Lo=t}}}}]);