"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[718],{7947:(e,t,i)=>{i.d(t,{z:()=>C});var n=i(1539),l=i(9384),a=i(1492),o=i(8095),d=i(6896),r=i(6259),s=i(3276),p=i(957);const m=i.p+"assets/images/char_spritesheet-6b6a6acd99180f91c1aad1383dddc3cd.png";var h=i(8172),c=i(1370);class u extends h.w{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this.requiredComponents=[c.T],this._collideSize=.5,this._tileWidth=1,this._tileHeight=1,this._gridEventMaps=[],this._directable=null,this.onKeyDown=e=>{if("e"!==e.key.toLowerCase())return;const t=this.gameObject.transform.position;let i,n;switch(this._directable.direction){case c.N.Up:i=0,n=this._tileHeight;break;case c.N.Down:i=0,n=-this._tileHeight;break;case c.N.Left:i=-this._tileWidth,n=0;break;case c.N.Right:i=this._tileWidth,n=0}for(let l=0;l<this._gridEventMaps.length;l++){this._gridEventMaps[l].tryInvokeEvent(t.x+i,t.y+n,this._collideSize,this._collideSize,this.gameObject)}}}awake(){this._directable=this.gameObject.getComponent(c.T)}onEnable(){this.engine.input.onKeyDown.addListener(this.onKeyDown)}onDisable(){this.engine.input.onKeyDown.removeListener(this.onKeyDown)}addGridEventMap(e){this._gridEventMaps.push(e)}}class C extends n.W{constructor(){super(...arguments),this._collideMaps=[],this._gridPointer=new l.s,this._gridPosition=new l.s,this._gridEventMap=new l.s}withCollideMap(e){return this._collideMaps.push(e),this}withGridPointer(e){return this._gridPointer=e,this}withGridPosition(e){return this._gridPosition=e,this}withGridEventMap(e){return this._gridEventMap=e,this}make(){return this.gameObjectBuilder.withComponent(a.$,(e=>{e.asyncSetImageFromPath(m,26,23),e.imageWidth=1,e.imageHeight=1,e.viewScale=1,e.filter.brightness=1.2})).withComponent(o.h,(e=>{e.addAnimation("down_walk",[27,28,29,30,31,32]),e.addAnimation("left_walk",[53,54,55,56,57,58]),e.addAnimation("right_walk",[79,80,81,82,83,84]),e.addAnimation("up_walk",[105,106,107,108,109,110]),e.addAnimation("down_idle",[34,35,36,37,38,39]),e.addAnimation("left_idle",[60,61,62,63,64,65]),e.addAnimation("right_idle",[86,87,88,89,90,91]),e.addAnimation("up_idle",[112,113,114,115,116,117]),e.addAnimation("down_hit",[41,42,43]),e.addAnimation("left_hit",[67,68,69]),e.addAnimation("right_hit",[93,94,95]),e.addAnimation("up_hit",[119,120,121]),e.addAnimation("down_push",[45,46,47,48,49,50]),e.addAnimation("left_push",[71,72,73,74,75,76]),e.addAnimation("right_push",[97,98,99,100,101,102]),e.addAnimation("up_push",[123,124,125,126,127,128]),e.addAnimation("down_climb",[157,158,159,160,161,162]),e.addAnimation("up_climb",[183,184,185,186,187,188]),e.addAnimation("down_shield_hit",[168,169,170,171,172]),e.addAnimation("left_shield_hit",[194,195,196,197,198]),e.addAnimation("right_shield_hit",[220,221,222,223,224]),e.addAnimation("up_shield_hit",[246,247,248,249,250]),e.addAnimation("down_shield",[174]),e.addAnimation("left_shield",[200]),e.addAnimation("right_shield",[226]),e.addAnimation("up_shield",[252]),e.addAnimation("death_all_air",[235,236,237,238,239,240,241,242,243,244]),e.addAnimation("falling_all_air",[287,288,289,290,291,292]),e.frameDuration=.1,e.playAnimation("down_idle")})).withComponent(d.j,(e=>{e.speed=4;for(const t of this._collideMaps)t.ref&&e.addCollideMap(t.ref);e.gridPointer=this._gridPointer.ref,this._gridPosition.ref&&(e.initPosition=this._gridPosition.ref)})).withComponent(r.q).withComponent(s.V,(e=>{this._gridEventMap.ref&&e.addGridEventMap(this._gridEventMap.ref)})).withComponent(u,(e=>{this._gridEventMap.ref&&e.addGridEventMap(this._gridEventMap.ref)})).withComponent(p.$,(e=>{e.runOnce=!1,e.offset=.5}))}}},6327:(e,t,i)=>{i.d(t,{l:()=>s});var n=i(1539),l=i(6987),a=i(70),o=i(9067),d=i(4669),r=i(9484);class s extends n.W{constructor(){super(...arguments),this._planeSize=null}withPlaneSize(e){return this._planeSize=e,this}make(){return this.gameObjectBuilder.withComponent(l.N,(e=>{e.offset=-100})).withComponent(a.n,(e=>{e.chunkSize=15,e.filter.brightness=1.5,e.tileResolutionX=16,e.tileResolutionY=16,o.E.loadImageFromPath(r.Z).then((t=>{var i,n;if(!e.exists)return;e.imageSources=[new d.I(t,18,13)];const l={i:0,a:24},a=null!=(i=null==(n=this._planeSize)?void 0:n.ref)?i:51,o=[];for(let e=0;e<a;e++){o[e]=[];for(let t=0;t<a;t++)o[e][t]=l}const r=Math.floor(a/2);e.drawTileFromTwoDimensionalArray(o,-r,-r)}))}))}}},2440:(e,t,i)=>{i.d(t,{Y:()=>h});var n=i(1539),l=i(9384),a=i(6987),o=i(590),d=i(9067),r=i(4669),s=i(4587),p=i(70),m=i(9484);class h extends n.W{constructor(){super(...arguments),this._collideTilemap=new l.s}getCollideTilemap(e){return this._collideTilemap=e,this}make(){return this.gameObjectBuilder.withComponent(a.N,(e=>{e.offset=-98})).withComponent(o.F,(e=>{e.chunkSize=15,e.filter.brightness=1.5,e.tileResolutionX=16,e.tileResolutionY=16,d.E.loadImageFromPath(m.Z).then((t=>{if(!e.exists)return;function i(e){return{i:0,a:e}}e.imageSources=[new r.I(t,18,13)];const n={o:()=>i(93),O:()=>i(94),"#":()=>i(61),"@":()=>i(75),$:()=>i(76),"*":()=>i(58),"^":()=>i(59)," ":()=>null};e.drawTileFromTwoDimensionalArray(s.d.map(["              ","   $          ","    #         ","              ","              "],n),-3,4),e.drawTileFromTwoDimensionalArray(s.d.map(["             ","          o  ","         @   ","     #       ","             ","             ","O            "],n),-7,-8)}))})).withComponent(p.n,(e=>{e.chunkSize=15,e.filter.brightness=1.5,e.tileResolutionX=16,e.tileResolutionY=16,d.E.loadImageFromPath(m.Z).then((t=>{if(!e.exists)return;function i(e){return{i:0,a:e}}e.imageSources=[new r.I(t,18,13)];const n={"\u3161":()=>i(47),"\u3163":()=>i(46),"\u3155":()=>i(11),"\u3151":()=>i(29),"\u314f":()=>i(44),"\u3153":()=>i(45),"\u3157":()=>i(62),"\u315c":()=>i(63),"\u3131":()=>i(8),"\u3134":()=>i(26),"\u3132":()=>i(9),"\u3139":()=>i(27),"\u315b":()=>i(28),"\u3160":()=>i(10),"\u3147":()=>null};e.drawTileFromTwoDimensionalArray(s.d.map(["\u3160","\u3134\u3131","\u3147\u314f\u3161\u3161\u3161\u3161\u3161\u3155","\u3147\u315b"],n),-3,4),e.drawTileFromTwoDimensionalArray(s.d.map(["\u3147\u3147\u3147\u3147\u3147\u3147\u3160","\u3147\u3147\u3147\u3147\u3147\u3147\u3163","\u3151\u3161\u3161\u3161\u3161\u3161\u3157\u3161\u315c\u3161\u3161\u3161\u3161\u3161\u3161\u3155","\u3147\u3147\u3147\u3147\u3147\u3147\u3147\u3147\u315b"],n),-8,-1),e.drawTileFromTwoDimensionalArray(s.d.map(["\u3147\u3147\u3147\u3147\u3147\u3160","\u3147\u3147\u3147\u3147\u3147\u3163","\u3147\u3147\u3147\u3147\u3147\u3163","\u3132\u3161\u3161\u3161\u3161\u3139","\u3163\u3147\u3147\u3147\u3147\u3147","\u315b\u3147\u3147\u3147\u3147\u3147"],n),-5,-8),e.drawTileFromTwoDimensionalArray(s.d.map(["\u3160","\u3163","\u3163","\u3163","\u3163","\u315b\u3147\u3147\u3147\u3147\u3147"],n),-5,-15);const l={"^":()=>i(56),"%":()=>i(57),"*":()=>i(72),"&":()=>i(73),"!":()=>i(90),"~":()=>i(91),o:()=>i(74),O:()=>i(92)," ":()=>null};e.drawTileFromTwoDimensionalArray(s.d.map(["     ^","","^ %  ~*"],l),3,4),e.drawTileFromTwoDimensionalArray(s.d.map(["O%    ^"," ^","","^  %"],l),1,-1),e.drawTileFromTwoDimensionalArray(s.d.map(["%     ^"," ","      *~","    % !~","     !**","o   !**~"],l),-2,-8)}))})).getComponent(o.F,this._collideTilemap)}}},1900:(e,t,i)=>{i.d(t,{P:()=>T});var n=i(1539),l=i(9384),a=i(6987),o=i(590),d=i(9067),r=i(4669),s=i(70),p=i(9484),m=i(6120);const h={i:0,a:4},c={i:0,a:5},u={i:0,a:7},C={i:0,a:22},w={i:0,a:25},b={i:0,a:40},f={i:0,a:41},g={i:0,a:43};class k{static make(e,t,i,n){const l=Array(t);for(let a=0;a<t;a++){l[a]=Array(e);for(let t=0;t<e;t++)l[a][t]=null}l[0][0]=h;for(let a=1;a<e-1;a++)l[0][a]=c;l[0][e-1]=u;for(let a=1;a<t-1;a++)l[a][0]=C,l[a][e-1]=w;l[t-1][0]=b;for(let a=1;a<e-1;a++)l[t-1][a]=f;return l[t-1][e-1]=g,null!==i&&(l[0][i]=null),null!==n&&(l[t-1][n]=null),l}static computeEntryPosition(e,t,i,n,l){return{top:null!==t?new m.F(n+t,l+e-1):null,bottom:null!==i?new m.F(n+i,l):null}}}class T extends n.W{constructor(){super(...arguments),this._collideTilemap=new l.s}getCollideTilemap(e){return this._collideTilemap=e,this}make(){return this.gameObjectBuilder.withComponent(a.N,(e=>{e.offset=-99})).withComponent(o.F,(e=>{e.chunkSize=15,e.filter.brightness=1.5,e.tileResolutionX=16,e.tileResolutionY=16,d.E.loadImageFromPath(p.Z).then((t=>{if(e.exists){e.imageSources=[new r.I(t,18,13)];for(const t of T._islandList)e.drawTileFromTwoDimensionalArray(k.make(t.width,t.height,t.topEntry,t.bottomEntry),t.x,t.y)}}))})).withComponent(s.n,(e=>{e.chunkSize=15,e.filter.brightness=1.5,e.tileResolutionX=16,e.tileResolutionY=16;d.E.loadImageFromPath(p.Z).then((t=>{if(e.exists){e.imageSources=[new r.I(t,18,13)];for(const t of T._islandList){const i=k.computeEntryPosition(t.height,t.topEntry,t.bottomEntry,t.x,t.y);i.top&&e.drawTile(i.top.x,i.top.y,0,6),i.bottom&&e.drawTile(i.bottom.x,i.bottom.y,0,42)}}}))})).getComponent(o.F,this._collideTilemap)}}T._islandList=[{width:16,height:6,topEntry:1,bottomEntry:2,x:-4,y:3},{width:15,height:8,topEntry:8,bottomEntry:3,x:-8,y:-9}]},3599:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>M,contentTitle:()=>_,default:()=>v,frontMatter:()=>P,metadata:()=>y,toc:()=>j});var n=i(7462),l=(i(7294),i(3905)),a=i(7346),o=i(3274),d=i(9384),r=i(9913),s=i(2684),p=i(2182),m=i(5365),h=i(3361),c=i(2138),u=i(1285),C=i(4532),w=i(7947),b=i(6327),f=i(2440),g=i(1900);class k extends o.A{run(){const e=this.instantiater,t=new d.s,i=new d.s,n=new d.s,l=new d.s;return this.sceneBuilder.withChild(e.buildGameObject("tilemap").withChild(e.buildPrefab("background",b.l,new C.P(0,0,-3)).make()).withChild(e.buildPrefab("islands",g.P,new C.P(0,0,-2)).getCollideTilemap(n).make()).withChild(e.buildPrefab("detail",f.Y,new C.P(0,0,-1)).getCollideTilemap(l).make())).withChild(e.buildGameObject("collision").withComponent(r.r,(e=>{e.showCollider=!1;const t=13;for(let i=-13;i<=t;i++)e.addCollider(t,i),e.addCollider(i,t),e.addCollider(-13,i),e.addCollider(i,-13)})).getComponent(r.r,i)).withChild(e.buildPrefab("player",w.z).withCollideMap(i).withCollideMap(n).withCollideMap(l).make().getGameObject(t)).withChild(e.buildGameObject("camera").withComponent(s.V,(e=>{e.viewSize=4})).withComponent(p.Y,(e=>{e.mouseMoveButton=0,e.minViewSize=4,e.maxViewSize=4})).withComponent(m.K,(e=>{e.setTrackTarget(t.ref)})))}}class T extends o.A{run(){const e=this.instantiater,t=new d.s,i=new d.s,n=new d.s,l=new d.s,a=new d.s;return this.sceneBuilder.withChild(e.buildGameObject("tilemap").withChild(e.buildPrefab("background",b.l,new C.P(0,0,-3)).make()).withChild(e.buildPrefab("islands",g.P,new C.P(0,0,-2)).getCollideTilemap(l).make()).withChild(e.buildPrefab("detail",f.Y,new C.P(0,0,-1)).getCollideTilemap(a).make())).withChild(e.buildGameObject("collision").withComponent(r.r,(e=>{e.showCollider=!1;const t=13;for(let i=-13;i<=t;i++)e.addCollider(t,i),e.addCollider(i,t),e.addCollider(-13,i),e.addCollider(i,-13)})).withComponent(h.I,(e=>{e.showCollider=!0})).getComponent(r.r,i).getComponent(h.I,n)).withChild(e.buildGameObject("test-object",new C.P(2,1,0)).withComponent(c.w,(e=>{const t=document.createElement("div");t.style.backgroundColor="red",e.element=t})).withComponent(u.u,(e=>{e.gridObjectCollideMap=n.ref,e.addCollider(0,0)}))).withChild(e.buildPrefab("player",w.z).withCollideMap(i).withCollideMap(n).withCollideMap(l).withCollideMap(a).make().getGameObject(t)).withChild(e.buildGameObject("camera").withComponent(s.V,(e=>{e.viewSize=4})).withComponent(p.Y,(e=>{e.mouseMoveButton=0,e.minViewSize=4,e.maxViewSize=4})).withComponent(m.K,(e=>{e.setTrackTarget(t.ref)})))}}const P={},_="Add Collide Map",y={unversionedId:"tutorial-2dtopdown/add-collide-map",id:"tutorial-2dtopdown/add-collide-map",title:"Add Collide Map",description:"This time, we will use a collide map that operates based on static objects.",source:"@site/docs/2-tutorial-2dtopdown/9-add-collide-map.mdx",sourceDirName:"2-tutorial-2dtopdown",slug:"/tutorial-2dtopdown/add-collide-map",permalink:"/the-world-engine.ts/build/docs/tutorial-2dtopdown/add-collide-map",draft:!1,editUrl:"https://github.com/The-World-Space/the-world-engine.ts/tree/main/docs/docusaurus/docs/2-tutorial-2dtopdown/9-add-collide-map.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Collide Map Basic",permalink:"/the-world-engine.ts/build/docs/tutorial-2dtopdown/collide-map-basic"},next:{title:"Zaxis Sorting",permalink:"/the-world-engine.ts/build/docs/tutorial-2dtopdown/zaxis-sorting"}},M={},j=[{value:"CssCollideTilemapChunkRenderer",id:"csscollidetilemapchunkrenderer",level:2},{value:"GridObjectCollideMap",id:"gridobjectcollidemap",level:2}],R={toc:j};function v(e){let{components:t,...i}=e;return(0,l.kt)("wrapper",(0,n.Z)({},R,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"add-collide-map"},"Add Collide Map"),(0,l.kt)("p",null,"This time, we will use a collide map that operates based on static objects."),(0,l.kt)("h2",{id:"csscollidetilemapchunkrenderer"},"CssCollideTilemapChunkRenderer"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"CssCollideTilemapChunkRender")," is same as the ",(0,l.kt)("inlineCode",{parentName:"p"},"CssTilemapChunkRender"),", but it also automatically installs the collider where the tiles are placed."),(0,l.kt)("p",null,"By replaceing the island tilemap into a collide tilemap, we can immediately implement collision handling for island without placing colliders daily."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/asset/prefab/world/IslandPrefab.ts"',title:'"src/asset/prefab/world/IslandPrefab.ts"'},"//...\n\nexport class IslandPrefab extends Prefab {\n    private static readonly _islandList = /* ... */;\n\n    // added: collideTilemap PrefabRef\n    private _collideTilemap = new PrefabRef<CssCollideTilemapChunkRenderer>();\n\n    public getCollideTilemap(ref: PrefabRef<CssCollideTilemapChunkRenderer>): this {\n        this._collideTilemap = ref;\n        return this;\n    }\n\n    public override make(): GameObjectBuilder {\n\n        return this.gameObjectBuilder\n            // replaced: CssTilemapChunkRenderer -> CssCollideTilemapChunkRenderer\n            .withComponent(CssCollideTilemapChunkRenderer, c => {\n                //...\n            })\n\n            .withComponent(CssTilemapChunkRenderer, c => {\n                //...\n            })\n\n            // added: get CollideTilemap PrefabRef\n            .getComponent(CssCollideTilemapChunkRenderer, this._collideTilemap)\n        ;\n    }\n}\n")),(0,l.kt)("p",null,"I just modified 'CssTilemapChunkRender' to 'CssCollideTilemapChunkRender' in the ",(0,l.kt)("inlineCode",{parentName:"p"},"IslandPrefab")," and get component to PrefabRef to inject the collidemap to the player."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/asset/Bootstrapper.ts"',title:'"src/asset/Bootstrapper.ts"'},'//...\n// added: CollideTilemap PrefabRef\nconst collideTilemap = new PrefabRef<CssCollideTilemapChunkRenderer>();\n\nreturn this.sceneBuilder\n    .withChild(instantiater.buildGameObject("tilemap")\n        .withChild(instantiater.buildPrefab("background", BackgroundPrefab, new Vector3(0, 0, -3))\n            .make())\n\n        .withChild(instantiater.buildPrefab("islands", IslandPrefab, new Vector3(0, 0, -2))\n            // added: get CollideTilemap to PrefabRef\n            .getCollideTilemap(collideTilemap).make())\n        //...\n\n    .withChild(instantiater.buildPrefab("player", PlayerPrefab)\n        .withCollideMap(collideMap)\n        .withCollideMap(collideTilemap)// added: inject collideTilemap\n//...\n')),(0,l.kt)("p",null,"Inject collideTilemap to the player."),(0,l.kt)("p",null,"I'll do the same for ",(0,l.kt)("inlineCode",{parentName:"p"},"DetailPrefab"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/asset/prefab/world/DetailPrefab.ts"',title:'"src/asset/prefab/world/DetailPrefab.ts"'},"//...\nexport class DetailPrefab extends Prefab {\n    // added: collideTilemap PrefabRef\n    private _collideTilemap = new PrefabRef<CssCollideTilemapChunkRenderer>();\n\n    public getCollideTilemap(ref: PrefabRef<CssCollideTilemapChunkRenderer>): this {\n        this._collideTilemap = ref;\n        return this;\n    }\n\n    public override make(): GameObjectBuilder {\n        return this.gameObjectBuilder\n            // replaced: CssTilemapChunkRenderer -> CssCollideTilemapChunkRenderer\n            .withComponent(CssCollideTilemapChunkRenderer, c => {\n                //...\n            })\n            .withComponent(CssTilemapChunkRenderer, c => {\n                //...\n            })\n            // added: get CollideTilemap PrefabRef\n            .getComponent(CssCollideTilemapChunkRenderer, this._collideTilemap)\n        ;\n    }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/asset/Bootstrapper.ts"',title:'"src/asset/Bootstrapper.ts"'},'//...\n// added: CollideTilemap PrefabRef for DetailPrefab\nconst collideTilemap2 = new PrefabRef<CssCollideTilemapChunkRenderer>();\n\nreturn this.sceneBuilder\n    .withChild(instantiater.buildGameObject("tilemap")\n        .withChild(instantiater.buildPrefab("background", BackgroundPrefab, new Vector3(0, 0, -3))\n            .make())\n\n        .withChild(instantiater.buildPrefab("islands", IslandPrefab, new Vector3(0, 0, -2))\n            .getCollideTilemap(collideTilemap).make())\n    \n        .withChild(instantiater.buildPrefab("detail", DetailPrefab, new Vector3(0, 0, -1))\n            // added: get CollideTilemap to PrefabRef\n            .getCollideTilemap(collideTilemap2).make())\n\n    .withChild(instantiater.buildPrefab("player", PlayerPrefab)\n        .withCollideMap(collideMap)\n        .withCollideMap(collideTilemap)\n        .withCollideMap(collideTilemap2)// added: inject collideTilemap\n//...\n')),(0,l.kt)(a.Z,{bootstrapper:k,allowScroll:!0,mdxType:"DocumentGame"}),(0,l.kt)("p",null,"The elements rendered in tiles are now collidable."),(0,l.kt)("h2",{id:"gridobjectcollidemap"},"GridObjectCollideMap"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"GridObjectCollideMap")," creates colliders based on the position of static objects."),(0,l.kt)("p",null,"Below is the code for the default setting for using ",(0,l.kt)("inlineCode",{parentName:"p"},"GridObjectCollideMap"),".\nIn typical situations, only one ",(0,l.kt)("inlineCode",{parentName:"p"},"GridObjectCollideMap")," is needed in the world."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/asset/Bootstrapper.ts"',title:'"src/asset/Bootstrapper.ts"'},'//...\n// added: GridObjectCollideMap PrefabRef\nconst objectCollideMap = new PrefabRef<GridObjectCollideMap>();\nconst collideTilemap = new PrefabRef<CssCollideTilemapChunkRenderer>();\nconst collideTilemap2 = new PrefabRef<CssCollideTilemapChunkRenderer>();\n\nreturn this.sceneBuilder\n    //...\n    .withChild(instantiater.buildGameObject("collision")\n        .withComponent(GridCollideMap, c => {\n            //...\n        })\n        // added: GridObjectCollideMap\n        .withComponent(GridObjectCollideMap, c => {\n            c.showCollider = true;\n        })\n        .getComponent(GridCollideMap, collideMap)\n        // added: get GridObjectCollideMap to PrefabRef\n        .getComponent(GridObjectCollideMap, objectCollideMap))\n\n    .withChild(instantiater.buildPrefab("player", PlayerPrefab)\n        .withCollideMap(collideMap)\n        // added: inject GridObjectCollideMap\n        .withCollideMap(objectCollideMap)\n        //...\n')),(0,l.kt)("p",null,"In this state, you can now add objects that have colliders to the world."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/asset/Bootstrapper.ts"',title:'"src/asset/Bootstrapper.ts"'},'.withChild(instantiater.buildGameObject("test-object", new Vector3(2, 1, 0))\n    .withComponent(CssHtmlElementRenderer, c => {\n        const div = document.createElement("div");\n        div.style.backgroundColor = "red";\n        c.element = div;\n    })\n    // GridColider is dependent on GridObjectCollideMap.\n    // Collider will be created based on the position of the object where GridCollider exists.\n    .withComponent(GridCollider, c => {\n        c.gridObjectCollideMap = objectCollideMap.ref!;\n        c.addCollider(0, 0);\n    }))\n')),(0,l.kt)("p",null,"For this object, colliders were added to 0, 0 of object space."),(0,l.kt)(a.Z,{bootstrapper:T,allowScroll:!0,mdxType:"DocumentGame"}),(0,l.kt)("p",null,"If you look at the results, you can see that colliders are created in 2, 1 in the world space."),(0,l.kt)("p",null,"Later, We will use this to create static objects easily. For now, you can erase the test object."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"Collider is placed once and not updated by object position. (for performance)"),(0,l.kt)("p",{parentName:"admonition"},"However, you can also manually update ",(0,l.kt)("inlineCode",{parentName:"p"},"GridCollider")," by disabling it once and then enabling it."),(0,l.kt)("p",{parentName:"admonition"},"It has not yet been decided whether to provide this function as a method in the future.")))}v.isMDXComponent=!0},9484:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/Overworld_Tileset-1c44075b314e79caada3455aa25f5809.png"}}]);